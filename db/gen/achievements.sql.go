// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: achievements.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAchievement = `-- name: CreateAchievement :one
INSERT INTO achievements (
    name,
    description,
    criteria,
    metadata
) VALUES (
    $1::text,
    $2::text,
    $3::jsonb,
    $4::jsonb
) RETURNING id, name, description, criteria, metadata
`

type CreateAchievementParams struct {
	Column1 string `json:"column1"`
	Column2 string `json:"column2"`
	Column3 []byte `json:"column3"`
	Column4 []byte `json:"column4"`
}

func (q *Queries) CreateAchievement(ctx context.Context, arg CreateAchievementParams) (Achievement, error) {
	row := q.db.QueryRow(ctx, createAchievement,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var i Achievement
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Criteria,
		&i.Metadata,
	)
	return i, err
}

const createUserAchievement = `-- name: CreateUserAchievement :one
INSERT INTO user_achievements (
    user_id,
    achievement_id,
    progress
) VALUES (
    $1::uuid,
    $2::bigint,
    $3::jsonb
) RETURNING user_id, achievement_id, unlocked_at, progress
`

type CreateUserAchievementParams struct {
	Column1 pgtype.UUID `json:"column1"`
	Column2 int64       `json:"column2"`
	Column3 []byte      `json:"column3"`
}

func (q *Queries) CreateUserAchievement(ctx context.Context, arg CreateUserAchievementParams) (UserAchievement, error) {
	row := q.db.QueryRow(ctx, createUserAchievement, arg.Column1, arg.Column2, arg.Column3)
	var i UserAchievement
	err := row.Scan(
		&i.UserID,
		&i.AchievementID,
		&i.UnlockedAt,
		&i.Progress,
	)
	return i, err
}

const getAchievementByID = `-- name: GetAchievementByID :one
SELECT id, name, description, criteria, metadata FROM achievements
WHERE id = $1::bigint
`

func (q *Queries) GetAchievementByID(ctx context.Context, dollar_1 int64) (Achievement, error) {
	row := q.db.QueryRow(ctx, getAchievementByID, dollar_1)
	var i Achievement
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Criteria,
		&i.Metadata,
	)
	return i, err
}

const getUserAchievements = `-- name: GetUserAchievements :many
SELECT 
    ua.user_id, ua.achievement_id, ua.unlocked_at, ua.progress,
    a.name,
    a.description,
    a.criteria,
    a.metadata
FROM user_achievements ua
JOIN achievements a ON ua.achievement_id = a.id
WHERE ua.user_id = $1::uuid
`

type GetUserAchievementsRow struct {
	UserID        pgtype.UUID        `json:"userId"`
	AchievementID int64              `json:"achievementId"`
	UnlockedAt    pgtype.Timestamptz `json:"unlockedAt"`
	Progress      []byte             `json:"progress"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	Criteria      []byte             `json:"criteria"`
	Metadata      []byte             `json:"metadata"`
}

func (q *Queries) GetUserAchievements(ctx context.Context, dollar_1 pgtype.UUID) ([]GetUserAchievementsRow, error) {
	rows, err := q.db.Query(ctx, getUserAchievements, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAchievementsRow
	for rows.Next() {
		var i GetUserAchievementsRow
		if err := rows.Scan(
			&i.UserID,
			&i.AchievementID,
			&i.UnlockedAt,
			&i.Progress,
			&i.Name,
			&i.Description,
			&i.Criteria,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserAchievementProgress = `-- name: UpdateUserAchievementProgress :one
UPDATE user_achievements
SET progress = $3::jsonb
WHERE user_id = $1::uuid AND achievement_id = $2::bigint
RETURNING user_id, achievement_id, unlocked_at, progress
`

type UpdateUserAchievementProgressParams struct {
	Column1 pgtype.UUID `json:"column1"`
	Column2 int64       `json:"column2"`
	Column3 []byte      `json:"column3"`
}

func (q *Queries) UpdateUserAchievementProgress(ctx context.Context, arg UpdateUserAchievementProgressParams) (UserAchievement, error) {
	row := q.db.QueryRow(ctx, updateUserAchievementProgress, arg.Column1, arg.Column2, arg.Column3)
	var i UserAchievement
	err := row.Scan(
		&i.UserID,
		&i.AchievementID,
		&i.UnlockedAt,
		&i.Progress,
	)
	return i, err
}
