// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: auth.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuthAccount = `-- name: CreateAuthAccount :one
INSERT INTO auth_accounts (
    user_id,
    email,
    auth_type,
    auth_id,
    auth_data,
    verified
) VALUES (
    $1::uuid,
    $2::email,
    $3::auth_type,
    $4::text,
    $5::jsonb,
    $6::boolean
) RETURNING id, user_id, email, auth_type, auth_id, auth_data, verified, created_at, last_login_at
`

type CreateAuthAccountParams struct {
	Column1 pgtype.UUID `json:"column1"`
	Column2 interface{} `json:"column2"`
	Column3 AuthType    `json:"column3"`
	Column4 string      `json:"column4"`
	Column5 []byte      `json:"column5"`
	Column6 bool        `json:"column6"`
}

// db/queries/auth.sql
func (q *Queries) CreateAuthAccount(ctx context.Context, arg CreateAuthAccountParams) (AuthAccount, error) {
	row := q.db.QueryRow(ctx, createAuthAccount,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var i AuthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.AuthType,
		&i.AuthID,
		&i.AuthData,
		&i.Verified,
		&i.CreatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getAuthAccountByEmail = `-- name: GetAuthAccountByEmail :one
SELECT id, user_id, email, auth_type, auth_id, auth_data, verified, created_at, last_login_at FROM auth_accounts
WHERE email = $1::email
`

func (q *Queries) GetAuthAccountByEmail(ctx context.Context, dollar_1 interface{}) (AuthAccount, error) {
	row := q.db.QueryRow(ctx, getAuthAccountByEmail, dollar_1)
	var i AuthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.AuthType,
		&i.AuthID,
		&i.AuthData,
		&i.Verified,
		&i.CreatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getAuthAccountsByUserID = `-- name: GetAuthAccountsByUserID :many
SELECT id, user_id, email, auth_type, auth_id, auth_data, verified, created_at, last_login_at FROM auth_accounts
WHERE user_id = $1::uuid
`

func (q *Queries) GetAuthAccountsByUserID(ctx context.Context, dollar_1 pgtype.UUID) ([]AuthAccount, error) {
	rows, err := q.db.Query(ctx, getAuthAccountsByUserID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthAccount
	for rows.Next() {
		var i AuthAccount
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.AuthType,
			&i.AuthID,
			&i.AuthData,
			&i.Verified,
			&i.CreatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAuthAccount = `-- name: UpdateAuthAccount :one
UPDATE auth_accounts
SET 
    email = COALESCE($2::email, email),
    auth_data = COALESCE($3::jsonb, auth_data),
    verified = COALESCE($4::boolean, verified),
    last_login_at = CURRENT_TIMESTAMP
WHERE id = $1::uuid
RETURNING id, user_id, email, auth_type, auth_id, auth_data, verified, created_at, last_login_at
`

type UpdateAuthAccountParams struct {
	Column1 pgtype.UUID `json:"column1"`
	Column2 interface{} `json:"column2"`
	Column3 []byte      `json:"column3"`
	Column4 bool        `json:"column4"`
}

func (q *Queries) UpdateAuthAccount(ctx context.Context, arg UpdateAuthAccountParams) (AuthAccount, error) {
	row := q.db.QueryRow(ctx, updateAuthAccount,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var i AuthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.AuthType,
		&i.AuthID,
		&i.AuthData,
		&i.Verified,
		&i.CreatedAt,
		&i.LastLoginAt,
	)
	return i, err
}
