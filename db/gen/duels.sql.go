// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: duels.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDuel = `-- name: CreateDuel :one
INSERT INTO duels (
    p1_id,
    p2_id,
    duel_type
) VALUES (
    $1::uuid,
    $2::uuid,
    $3::duel_type
) RETURNING id, p1_id, p2_id, date, winner_id, loser_id, duel_type, p1_elo_delta, p2_elo_delta
`

type CreateDuelParams struct {
	Column1 pgtype.UUID `json:"column1"`
	Column2 pgtype.UUID `json:"column2"`
	Column3 DuelType    `json:"column3"`
}

func (q *Queries) CreateDuel(ctx context.Context, arg CreateDuelParams) (Duel, error) {
	row := q.db.QueryRow(ctx, createDuel, arg.Column1, arg.Column2, arg.Column3)
	var i Duel
	err := row.Scan(
		&i.ID,
		&i.P1ID,
		&i.P2ID,
		&i.Date,
		&i.WinnerID,
		&i.LoserID,
		&i.DuelType,
		&i.P1EloDelta,
		&i.P2EloDelta,
	)
	return i, err
}

const getDuelByID = `-- name: GetDuelByID :one
SELECT id, p1_id, p2_id, date, winner_id, loser_id, duel_type, p1_elo_delta, p2_elo_delta FROM duels
WHERE id = $1::bigint
`

func (q *Queries) GetDuelByID(ctx context.Context, dollar_1 int64) (Duel, error) {
	row := q.db.QueryRow(ctx, getDuelByID, dollar_1)
	var i Duel
	err := row.Scan(
		&i.ID,
		&i.P1ID,
		&i.P2ID,
		&i.Date,
		&i.WinnerID,
		&i.LoserID,
		&i.DuelType,
		&i.P1EloDelta,
		&i.P2EloDelta,
	)
	return i, err
}

const getUserDuels = `-- name: GetUserDuels :many
SELECT id, p1_id, p2_id, date, winner_id, loser_id, duel_type, p1_elo_delta, p2_elo_delta FROM duels
WHERE p1_id = $1::uuid OR p2_id = $1::uuid
ORDER BY date DESC
LIMIT $2::integer OFFSET $3::integer
`

type GetUserDuelsParams struct {
	Column1 pgtype.UUID `json:"column1"`
	Column2 int32       `json:"column2"`
	Column3 int32       `json:"column3"`
}

func (q *Queries) GetUserDuels(ctx context.Context, arg GetUserDuelsParams) ([]Duel, error) {
	rows, err := q.db.Query(ctx, getUserDuels, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.P1ID,
			&i.P2ID,
			&i.Date,
			&i.WinnerID,
			&i.LoserID,
			&i.DuelType,
			&i.P1EloDelta,
			&i.P2EloDelta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDuelOutcome = `-- name: UpdateDuelOutcome :one
UPDATE duels
SET 
    winner_id = $2::uuid,
    loser_id = $3::uuid,
    p1_elo_delta = $4::integer,
    p2_elo_delta = $5::integer
WHERE id = $1::bigint
RETURNING id, p1_id, p2_id, date, winner_id, loser_id, duel_type, p1_elo_delta, p2_elo_delta
`

type UpdateDuelOutcomeParams struct {
	Column1 int64       `json:"column1"`
	Column2 pgtype.UUID `json:"column2"`
	Column3 pgtype.UUID `json:"column3"`
	Column4 int32       `json:"column4"`
	Column5 int32       `json:"column5"`
}

func (q *Queries) UpdateDuelOutcome(ctx context.Context, arg UpdateDuelOutcomeParams) (Duel, error) {
	row := q.db.QueryRow(ctx, updateDuelOutcome,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var i Duel
	err := row.Scan(
		&i.ID,
		&i.P1ID,
		&i.P2ID,
		&i.Date,
		&i.WinnerID,
		&i.LoserID,
		&i.DuelType,
		&i.P1EloDelta,
		&i.P2EloDelta,
	)
	return i, err
}
